cv_fit <- glmnet::cv.glmnet(as.matrix(train_x), train_y, family = family, nfolds = nfolds, lambda = lambda, parallel = TRUE)
lasso_pred <- predict(cv_fit, s = cv_fit$lambda.min, newx = as.matrix(test_x))
mse <- mean((test_y - lasso_pred)^2)
mse
x = iris[,1:3]
y = iris[,4]
blasso <- function(x, y, loops = 2, nfolds = 10, family = "gaussian", lambda = NULL, seed = 987654321, ncores = 2){
doParallel::registerDoParallel(cores = ncores)
set.seed(seed)
varx <- colnames(x)
rowx <- nrow(x)
nvar <- ncol(x)
n <- length(y)
res <- vector("list", loops)
if(rowx != n){
stop("The number of rows in x is not equal to the length of y!")
}
res <- foreach::foreach(i = 1:loops) %dopar% {
## BOOTSTRAP
idx <- sample(1:n, replace = T)
new_matrix <- cbind(y, x)
new_matrix <- new_matrix[idx ,]
## TEST
idx_test <- sample(1:(n/3), replace = FALSE)
test <- new_matrix[idx_test ,]
test_x <- test[,-1]
test_y <- test[,1]
## TRAIN
train <- new_matrix[-idx_test ,]
train_x <- train[,-1]
train_y <- train[,1]
## LASSO
cv_fit <- glmnet::cv.glmnet(as.matrix(train_x), train_y, family = family, nfolds = nfolds, lambda = lambda, parallel = TRUE)
tmp_coeffs <- coef(cv_fit, s = "lambda.min")
final_coef <- data.frame(name = tmp_coeffs@Dimnames[[1]][tmp_coeffs@i + 1], coefficient = tmp_coeffs@x)
lasso_pred <- predict(cv_fit, s = cv_fit$lambda.min, newx = as.matrix(test_x))
mse <- mean((test_y - lasso_pred)^2)
res[[i]] <- list(final_coef, mse)
}
# message(crayon::blue(clisymbols::symbol$info, paste0("Work done in ", round(end_time - start_time, 2))))
return(res)
}
blaso(x,y)
blasso(x,y)
library(foreach)
blasso(x,y)
blasso <- function(x, y, loops = 2, nfolds = 10, family = "gaussian", lambda = NULL, seed = 987654321, ncores = 2){
doParallel::registerDoParallel(cores = ncores)
set.seed(seed)
varx <- colnames(x)
rowx <- nrow(x)
nvar <- ncol(x)
n <- length(y)
res <- vector("list", loops)
if(rowx != n){
stop("The number of rows in x is not equal to the length of y!")
}
res <- foreach::foreach(i = 1:loops) %dopar% {
## BOOTSTRAP
idx <- sample(1:n, replace = T)
new_matrix <- cbind(y, x)
new_matrix <- new_matrix[idx ,]
## TEST
idx_test <- sample(1:(n/3), replace = FALSE)
test <- new_matrix[idx_test ,]
test_x <- test[,-1]
test_y <- test[,1]
## TRAIN
train <- new_matrix[-idx_test ,]
train_x <- train[,-1]
train_y <- train[,1]
## LASSO
cv_fit <- glmnet::cv.glmnet(as.matrix(train_x), train_y, family = family, nfolds = nfolds, lambda = lambda, parallel = TRUE)
tmp_coeffs <- coef(cv_fit, s = "lambda.min")
final_coef <- data.frame(name = tmp_coeffs@Dimnames[[1]][tmp_coeffs@i + 1], coefficient = tmp_coeffs@x)
lasso_pred <- predict(cv_fit, s = cv_fit$lambda.min, newx = as.matrix(test_x))
mse <- mean((test_y - lasso_pred)^2)
res[i] <- list(final_coef, mse)
}
# message(crayon::blue(clisymbols::symbol$info, paste0("Work done in ", round(end_time - start_time, 2))))
return(res)
}
blasso(x,y)
blasso <- function(x, y, loops = 2, nfolds = 10, family = "gaussian", lambda = NULL, seed = 987654321, ncores = 2){
doParallel::registerDoParallel(cores = ncores)
set.seed(seed)
varx <- colnames(x)
rowx <- nrow(x)
nvar <- ncol(x)
n <- length(y)
res <- vector("list", loops)
if(rowx != n){
stop("The number of rows in x is not equal to the length of y!")
}
res <- foreach::foreach(i = 1:loops) %dopar% {
## BOOTSTRAP
idx <- sample(1:n, replace = T)
new_matrix <- cbind(y, x)
new_matrix <- new_matrix[idx ,]
## TEST
idx_test <- sample(1:(n/3), replace = FALSE)
test <- new_matrix[idx_test ,]
test_x <- test[,-1]
test_y <- test[,1]
## TRAIN
train <- new_matrix[-idx_test ,]
train_x <- train[,-1]
train_y <- train[,1]
## LASSO
cv_fit <- glmnet::cv.glmnet(as.matrix(train_x), train_y, family = family, nfolds = nfolds, lambda = lambda, parallel = TRUE)
tmp_coeffs <- coef(cv_fit, s = "lambda.min")
final_coef <- data.frame(name = tmp_coeffs@Dimnames[[1]][tmp_coeffs@i + 1], coefficient = tmp_coeffs@x)
lasso_pred <- predict(cv_fit, s = cv_fit$lambda.min, newx = as.matrix(test_x))
mse <- mean((test_y - lasso_pred)^2)
res[i] <- list(coeffs = final_coef, mse = mse)
}
# message(crayon::blue(clisymbols::symbol$info, paste0("Work done in ", round(end_time - start_time, 2))))
return(res)
}
blasso(x,y)
blasso <- function(x, y, loops = 2, nfolds = 10, family = "gaussian", lambda = NULL, seed = 987654321, ncores = 2){
tictoc::tic("blasso")
doParallel::registerDoParallel(cores = ncores)
set.seed(seed)
varx <- colnames(x)
rowx <- nrow(x)
nvar <- ncol(x)
n <- length(y)
res <- vector("list", loops)
if(rowx != n){
stop("The number of rows in x is not equal to the length of y!")
}
res <- foreach::foreach(i = 1:loops) %dopar% {
## BOOTSTRAP
idx <- sample(1:n, replace = T)
new_matrix <- cbind(y, x)
new_matrix <- new_matrix[idx ,]
## TEST
idx_test <- sample(1:(n/3), replace = FALSE)
test <- new_matrix[idx_test ,]
test_x <- test[,-1]
test_y <- test[,1]
## TRAIN
train <- new_matrix[-idx_test ,]
train_x <- train[,-1]
train_y <- train[,1]
## LASSO
cv_fit <- glmnet::cv.glmnet(as.matrix(train_x), train_y, family = family, nfolds = nfolds, lambda = lambda, parallel = TRUE)
tmp_coeffs <- coef(cv_fit, s = "lambda.min")
final_coef <- data.frame(name = tmp_coeffs@Dimnames[[1]][tmp_coeffs@i + 1], coefficient = tmp_coeffs@x)
lasso_pred <- predict(cv_fit, s = cv_fit$lambda.min, newx = as.matrix(test_x))
mse <- mean((test_y - lasso_pred)^2)
res[i] <- list(coeffs = final_coef, mse = mse)
}
# message(crayon::blue(clisymbols::symbol$info, paste0("Work done in ", round(end_time - start_time, 2))))
tictoc::toc()
return(res)
}
blasso(x,y)
aaa <- blasso(x,y)
blasso <- function(x, y, loops = 2, nfolds = 10, family = "gaussian", lambda = NULL, seed = 987654321, ncores = 2){
tictoc::tic()
doParallel::registerDoParallel(cores = ncores)
set.seed(seed)
varx <- colnames(x)
rowx <- nrow(x)
nvar <- ncol(x)
n <- length(y)
res <- vector("list", loops)
if(rowx != n){
stop("The number of rows in x is not equal to the length of y!")
}
res <- foreach::foreach(i = 1:loops) %dopar% {
## BOOTSTRAP
idx <- sample(1:n, replace = T)
new_matrix <- cbind(y, x)
new_matrix <- new_matrix[idx ,]
## TEST
idx_test <- sample(1:(n/3), replace = FALSE)
test <- new_matrix[idx_test ,]
test_x <- test[,-1]
test_y <- test[,1]
## TRAIN
train <- new_matrix[-idx_test ,]
train_x <- train[,-1]
train_y <- train[,1]
## LASSO
cv_fit <- glmnet::cv.glmnet(as.matrix(train_x), train_y, family = family, nfolds = nfolds, lambda = lambda, parallel = TRUE)
tmp_coeffs <- coef(cv_fit, s = "lambda.min")
final_coef <- data.frame(name = tmp_coeffs@Dimnames[[1]][tmp_coeffs@i + 1], coefficient = tmp_coeffs@x)
lasso_pred <- predict(cv_fit, s = cv_fit$lambda.min, newx = as.matrix(test_x))
mse <- mean((test_y - lasso_pred)^2)
res[i] <- list(coeffs = final_coef, mse = mse)
}
# message(crayon::blue(clisymbols::symbol$info, paste0("Work done in ", round(end_time - start_time, 2))))
tictoc::toc()
return(res)
}
aaa <- blasso(x,y)
devtools::document()
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::document()
pkgdown::build_site()
usethis::use_test("blasso")
?glmnet::glasso
รง
?glmnet::glasso
?glmnet::glmnet
ggplot2::diamonds
data <- ggplot2::diamonds
data <- ggplot2::diamonds
x <- data[,1,c (5:7,8:10)]
y <- data$price
#' @export
#'
#' @return
#' @references
#' @author
#'
#' @importFrom tictoc tic toc
#' @importFrom doParallel registerDoParallel
#' @importFrom foreach foreach %dopar%
#' @importFrom glmnet cv.glmnet
blasso <- function(x,
y,
loops = 2,
nfolds = 10,
family = "gaussian",
lambda = NULL,
seed = 987654321,
ncores = 2){
tictoc::tic()
doParallel::registerDoParallel(cores = ncores)
set.seed(seed)
varx <- colnames(x)
rowx <- nrow(x)
nvar <- ncol(x)
n <- length(y)
res <- vector("list", loops)
if(rowx != n){
stop("The number of rows in x is not equal to the length of y!")
}
res <- foreach::foreach(i = 1:loops) %dopar% {
## BOOTSTRAP
idx <- sample(1:n, replace = T)
new_matrix <- cbind(y, x)
new_matrix <- new_matrix[idx ,]
## TEST
idx_test <- sample(1:(n/3), replace = FALSE)
test <- new_matrix[idx_test ,]
test_x <- test[,-1]
test_y <- test[,1]
## TRAIN
train <- new_matrix[-idx_test ,]
train_x <- train[,-1]
train_y <- train[,1]
## LASSO
cv_fit <- glmnet::cv.glmnet(as.matrix(train_x), train_y, family = family, nfolds = nfolds, lambda = lambda, parallel = TRUE)
tmp_coeffs <- coef(cv_fit, s = "lambda.min")
final_coef <- data.frame(name = tmp_coeffs@Dimnames[[1]][tmp_coeffs@i + 1], coefficient = tmp_coeffs@x)
lasso_pred <- predict(cv_fit, s = cv_fit$lambda.min, newx = as.matrix(test_x))
mse <- mean((test_y - lasso_pred)^2)
res[i] <- list(coeffs = final_coef, mse = mse)
}
tictoc::toc()
return(res)
}
blasso(x, y)
blasso(x, y)
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::document()
blasso(x, y)
length(y)
nrow(x)
x <- as.matrix(data[,1,c (5:7,8:10)])
y <- data$price
blasso(x, y)
x
data <- ggplot2::diamonds
x <- as.matrix(data[,1,c(5:7,8:10)])
y <- data$price
blasso(x, y)
data <- ggplot2::diamonds
x <- as.matrix(data[,c(1, 5:7, 8:10)])
y <- data$price
blasso(x, y)
x
View(data)
data <- ggplot2::diamonds
x <- as.matrix(data[,c(1, 5:6, 8:10)])
y <- data$price
blasso(x, y)
res_blasso <- blasso(x, y)
View(data)
18989.61884 + (10129.45200*0.31) + (-188.33124*62.2) + (-99.81253*54) + (-1009.07086*4.35)
summary(data$price)
res_blasso
?glmnet::cv.glmnet
?glmnet::glmnet
?set.seed
citation("glmnet")
data <- ggplot2::diamonds
x <- as.matrix(data[,c(1, 5:6, 8:10)])
y <- data$color
y
loops = 2
alpha = 1
nfolds = 10
family = "gaussian"
seed = 987654321
ncores = 2
set.seed(seed)
varx <- colnames(x)
rowx <- nrow(x)
nvar <- ncol(x)
n <- length(y)
res <- vector("list", loops)
if(rowx != n){
stop("The number of rows in x is not equal to the length of y!")
}
idx <- sample(1:n, replace = T)
new_matrix <- cbind(y, x)
new_matrix <- new_matrix[idx ,]
idx_test <- sample(1:(n/3), replace = FALSE)
test <- new_matrix[idx_test ,]
test_x <- test[,-1]
test_y <- test[,1]
train <- new_matrix[-idx_test ,]
train_x <- train[,-1]
train_y <- train[,1]
family <- "multinomial"
cv_fit <- glmnet::cv.glmnet(as.matrix(train_x), train_y, alpha = alpha, family = family, nfolds = nfolds, parallel = TRUE)
tmp_coeffs <- coef(cv_fit, s = "lambda.min")
final_coef <- data.frame(name = tmp_coeffs@Dimnames[[1]][tmp_coeffs@i + 1], coefficient = tmp_coeffs@x)
tmp_coeffs
class(cv_fit)
cv_fit
tmp_coeffs <- coef(cv_fit, s = "lambda.min")
tmp_coeffs
class(tmp_coeffs)
tmp_coeffs@x
lasso_pred <- predict(cv_fit, s = "lambda.min", testX, type = 'response')
lasso_pred <- predict(cv_fit, s = "lambda.min", as.matrix(test_x), type = 'response')
lasso_pred
lasso_pred <- predict(cv_fit, s = "lambda.min", as.matrix(test_x), type = 'class')
lasso_pred
confusion_matrix <- ftable(train_y, lasso_pred)
lasso_pred <- predict(cv_fit, s = "lambda.min", as.matrix(test_x), type = 'class')
confusion_matrix <- ftable(train_y, lasso_pred)
predict(cv_fit, s = "lambda.min", as.matrix(test_x), type = 'class')
lasso_pred <- predict(cv_fit, s = "lambda.min", as.matrix(test_x), type = 'class')
lasso_pred <- predict(cv_fit, s = "lambda.min", as.matrix(test_x), type = 'response')
lasso_pred
usethis::use_r("cox_blasso")
load("CoxExample.RData")
data <- ggplot2::diamonds
x <- as.matrix(data[,c(1, 5:6, 8:10)])
y <- data$price
res_blasso <- blasso(x, y)
expect_true(class(res_blasso) == "list")
usethis::use_test("cox_blasso")
expect_equal(2 + 2, 4) # dummy test to run CI
library(glmnet)
library(survival)
survival::aml
survival::bladder
survival::cancer
data <- survival::cancer
View(data)
y <- data[,2:3]
data <- survival::cancer
y <- as.matrix(data[,2:3])
x <- as.matrix(data[,4:10])
loops = 2
alpha = 1
nfolds = 10
seed = 987654321
ncores = 2
set.seed(seed)
varx <- colnames(x)
rowx <- nrow(x)
nvar <- ncol(x)
n <- nrow(y)
res <- vector("list", loops)
if(ncol(y) != 2){
stop("y must be a matrix with two columns (time and status)")
}
if(rowx != n){
stop("The number of rows in x is not equal to the number of rows in y!")
}
idx <- sample(1:n, replace = T)
new_matrix <- cbind(y, x)
new_matrix <- new_matrix[idx ,]
idx_test <- sample(1:(n/3), replace = FALSE)
test <- new_matrix[idx_test ,]
test_x <- test[,-1:2]
test_y <- test[,1:2]
test_x <- test[,-c(1:2)]
test_y <- test[,1:2]
train <- new_matrix[-idx_test ,]
train_x <- train[,-c(1:2)]
train_y <- train[,1:2]
cv_fit <- glmnet::cv.glmnet(as.matrix(train_x), train_y, alpha = alpha, family = "cox", nfolds = nfolds, parallel = TRUE)
x <- as.matrix(data[,4:8])
set.seed(seed)
varx <- colnames(x)
rowx <- nrow(x)
nvar <- ncol(x)
n <- nrow(y)
idx <- sample(1:n, replace = T)
new_matrix <- cbind(y, x)
new_matrix <- new_matrix[idx ,]
idx_test <- sample(1:(n/3), replace = FALSE)
test <- new_matrix[idx_test ,]
test_x <- test[,-c(1:2)]
test_y <- test[,1:2]
train <- new_matrix[-idx_test ,]
train_x <- train[,-c(1:2)]
train_y <- train[,1:2]
cv_fit <- glmnet::cv.glmnet(as.matrix(train_x), train_y, alpha = alpha, family = "cox", nfolds = nfolds, parallel = TRUE)
y <- as.matrix(data[,2:3])
x <- as.matrix(data[,4:10])
x[is.na(x)] <- 10
set.seed(seed)
varx <- colnames(x)
rowx <- nrow(x)
nvar <- ncol(x)
n <- nrow(y)
idx <- sample(1:n, replace = T)
new_matrix <- cbind(y, x)
new_matrix <- new_matrix[idx ,]
idx_test <- sample(1:(n/3), replace = FALSE)
test <- new_matrix[idx_test ,]
test_x <- test[,-c(1:2)]
test_y <- test[,1:2]
train <- new_matrix[-idx_test ,]
train_x <- train[,-c(1:2)]
train_y <- train[,1:2]
cv_fit <- glmnet::cv.glmnet(as.matrix(train_x), train_y, alpha = alpha, family = "cox", nfolds = nfolds, parallel = TRUE)
cv_fit
tmp_coeffs <- coef(cv_fit, s = "lambda.min")
final_coef <- data.frame(name = tmp_coeffs@Dimnames[[1]][tmp_coeffs@i + 1], coefficient = tmp_coeffs@x)
final_coef
lasso_pred <- predict(cv_fit, s = cv_fit$lambda.min, newx = as.matrix(test_x))
lasso_pred
lasso_pred <- predict(cv_fit, s = cv_fit$lambda.min, newx = as.matrix(test_x), type = "response")
lasso_pred
#' @export
#'
#' @return A list with the results.
#' @references Jerome Friedman, Trevor Hastie, Robert Tibshirani (2010). Regularization Paths for Generalized Linear Models via Coordinate Descent. Journal of Statistical Software, 33(1), 1-22. URL http://www.jstatsoft.org/v33/i01/.
#' @author Pol Castellano-Escuder
#'
#' @importFrom tictoc tic toc
#' @importFrom doParallel registerDoParallel
#' @importFrom foreach foreach %dopar%
#' @importFrom glmnet cv.glmnet
cox_blasso <- function(x,
y,
loops = 2,
alpha = 1,
nfolds = 10,
seed = 987654321,
ncores = 2){
tictoc::tic()
doParallel::registerDoParallel(cores = ncores)
set.seed(seed)
varx <- colnames(x)
rowx <- nrow(x)
nvar <- ncol(x)
n <- nrow(y)
res <- vector("list", loops)
if(ncol(y) != 2){
stop("y must be a matrix with two columns (time and status)")
}
if(rowx != n){
stop("The number of rows in x is not equal to the number of rows in y!")
}
res <- foreach::foreach(i = 1:loops) %dopar% {
## BOOTSTRAP
idx <- sample(1:n, replace = T)
new_matrix <- cbind(y, x)
new_matrix <- new_matrix[idx ,]
## TEST
idx_test <- sample(1:(n/3), replace = FALSE)
test <- new_matrix[idx_test ,]
test_x <- test[,-c(1:2)]
test_y <- test[,1:2]
## TRAIN
train <- new_matrix[-idx_test ,]
train_x <- train[,-c(1:2)]
train_y <- train[,1:2]
## LASSO
cv_fit <- glmnet::cv.glmnet(as.matrix(train_x), train_y, alpha = alpha, family = "cox", nfolds = nfolds, parallel = TRUE)
tmp_coeffs <- coef(cv_fit, s = "lambda.min")
final_coef <- data.frame(name = tmp_coeffs@Dimnames[[1]][tmp_coeffs@i + 1], coefficient = tmp_coeffs@x)
lasso_pred <- predict(cv_fit, s = cv_fit$lambda.min, newx = as.matrix(test_x), type = "response") # hazards
res[i] <- list(coeffs = final_coef)
}
tictoc::toc()
return(res)
}
cox_blasso(x,y,loops = 10)
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::document()
pkgdown::build_site()
